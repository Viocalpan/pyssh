# Dependencies for pyssh
import time
import sys

import os
import threading
import cmd

from pexpect import pxssh, TIMEOUT

CRNL = '\r\n'

# experimentally derived that a sequence of tries with delays of
#  1, 5, 25, 125 secs worked to surmount a 1-second delay (via `tc` test)
RETRY_EXPONENT = 5

class PxsshWrapper(pxssh.pxssh):
    def __init__(self, delaybeforesend, sync_retries, options):
        self.sync_retries = sync_retries
        self.delaybeforesend=delaybeforesend
        super(PxsshWrapper, self).__init__(options=options)

    def sync_original_prompt(self, sync_multiplier=1.0):
        """
        override the pxssh method to allow retries with extended timeout intervals
        """
        # make two attempts to throw away, perhaps emptying any initial Message Of The Day.
        # In practice, the first request can take a huge amount of time, compared to subsequent requests,
        # so give it a 5-second max wait as a special case.
        self.sendline()
        self.wait_for_any_response(max_wait_secs=5)
        self.clear_response_channel()

        self.sendline()
        self.try_read_prompt(sync_multiplier)

        # Each retry should go more slowly to accommodate possible cpu load, network,
        # or other issues on the segment host that might delay when we receive the prompt.
        num_retries = self.sync_retries
        retry_attempt = 0
        success = False
        while (not success) and retry_attempt <= num_retries:
            # each retry will get an exponentially longer timeout interval
            sync_multiplier_for_this_retry = sync_multiplier * (RETRY_EXPONENT ** retry_attempt)
            start = time.time()

            self.sendline()
            first_prompt = self.try_read_prompt(sync_multiplier_for_this_retry)

            self.sendline()
            second_prompt = self.try_read_prompt(sync_multiplier_for_this_retry)

            success = self.are_prompts_similar(first_prompt, second_prompt)
            if not success:
                retry_attempt += 1
                if retry_attempt <= num_retries:
                    # This attempt has failed to allow enough time.
                    # We want to "clear the runway" before another attempt.
                    # The next attempt will have a wait that is exponent times as long.
                    # To clear the runway, we sleep for about as long as this upcoming retry.
                    # Thus, the overall duration of this retry cycle becomes
                    # roughly equivalent to the timeout used by the next attempt
                    time.sleep(RETRY_EXPONENT * sync_multiplier_for_this_retry)
                    self.clear_response_channel()

        return success

    def clear_response_channel(self):
        """remove any readily-available characters. stop as soon as even a little wait time is discovered"""
        prompt = "dummy non empty"
        while prompt:
            try:
                prompt = self.read_nonblocking(size=1, timeout=0.01)

            except TIMEOUT as Err:
                break

    def wait_for_any_response(self, max_wait_secs=5):
        duration = 0
        while duration < max_wait_secs:
            start = time.time()
            try:
                prompt = self.read_nonblocking(size=1, timeout=0.01)
                if prompt:
                    break
            except TIMEOUT as Err:
                duration += time.time() - start

    def is_prompt_bad(self, prompt_output):
        return len(prompt_output) == 0 or prompt_output == CRNL

    def are_prompts_similar(self, prompt_one, prompt_two):
        if self.is_prompt_bad(prompt_one) or self.is_prompt_bad(prompt_two):
            return False

        if len(prompt_one) == 0:
            return False  # it will be used as the denominator of a ratio
        lev_dist = self.levenshtein_distance(prompt_one, prompt_two)
        lev_ratio = float(lev_dist) / len(prompt_one)

        if lev_ratio < 0.4:
            return True
        else:
            pass
        return False


def to_str(S):
  if isinstance(S, bytes):
      value = S.decode('utf-8')
  else:
      value = S
  return value


# Session is a command session, derived from a base class cmd.Cmd
class Session(cmd.Cmd):
    '''Implements a list of open ssh sessions ready to execute commands'''
    verbose = False
    hostList = []
    userName = None
    echoCommand = False

    class SessionError(BaseException):
        pass

    class SessionCmdExit(BaseException):
        pass

    def __init__(self, hostList=None, userName=None):
        cmd.Cmd.__init__(self)
        self.pxssh_list = []
        self.prompt = '=> '
        self.peerStringFormatRaw = None
        if hostList:
            for host in hostList:
                self.hostList.append(host)
        if userName: self.userName = userName

    def peerStringFormat(self):
        if self.peerStringFormatRaw: return self.peerStringFormatRaw
        cnt = 0
        for p in self.pxssh_list:
            if cnt < len(p.x_peer): cnt = len(p.x_peer)
        self.peerStringFormatRaw = "[%%%ds]" % cnt
        return self.peerStringFormatRaw

    def login(self, hostList=None, userName=None, delaybeforesend=0.05, sync_multiplier=1.0, sync_retries=3):
        """This is the normal entry point used to add host names to the object and log in to each of them"""
        if self.verbose: print('\n[Reset ...]')
        if not (self.hostList or hostList):
            raise self.SessionError('No host list available to Login method')
        if not (self.userName or userName):
            raise self.SessionError('No user name available to Login method')

        # Cleanup
        self.clean()

        if hostList:  # We have a new hostlist to use, initialize it
            self.hostList = []
            for host in hostList:
                self.hostList.append(host)
        if userName:
            self.userName = userName  # We have a new userName to use

        # MPP-6583.  Save off term type and set to nothing before creating ssh process
        origTERM = os.getenv('TERM', None)
        os.putenv('TERM', '')

        good_list = []
        print_lock = threading.Lock()

        def connect_host(hostname, p):
            self.hostList.append(hostname)
            try:
                # The sync_multiplier value is passed onto pexpect.pxssh which is used to determine timeout
                # values for prompt verification after an ssh connection is established.
                p.login(hostname, self.userName, sync_multiplier=sync_multiplier)
                p.x_peer = hostname
                p.x_pid = p.pid
                good_list.append(p)
                if self.verbose:
                    with print_lock:
                        print(f'[INFO] login {hostname}')
            except Exception as Err:
                with print_lock:
                    print(f'[ERROR] unable to login to {hostname}')
                    if type(Err) is pxssh.ExceptionPxssh:
                        print(Err)
                    elif type(Err) is pxssh.EOF:
                        print('Could not acquire connection.')
                    else:
                        print('hint: use pysshexK to setup public-key authentication between hosts')

        thread_list = []
        for host in hostList:
            p = PxsshWrapper(delaybeforesend=delaybeforesend,
                                             sync_retries=sync_retries,
                                             options={"StrictHostKeyChecking": "no",
                                                      "BatchMode": "yes"})
            t = threading.Thread(target=connect_host, args=(host, p))
            t.start()
            thread_list.append(t)

        for t in thread_list:
            t.join()

        # Restore terminal type
        if origTERM:
            os.putenv('TERM', origTERM)

        self.pxssh_list = good_list

    def close(self):
        return self.clean()

    def reset(self):
        '''reads from all the ssh connections to make sure we dont have any pending cruft'''
        for s in self.pxssh_list:
            s.readlines()

    def clean(self):
        net_return_code = self.closePxsshList(self.pxssh_list)
        self.pxssh_list = []
        return net_return_code

    def emptyline(self):
        pass

    def escapeLine(self, line):
        '''Escape occurrences of \ and $ as needed and package the line as an "eval" shell command'''
        line = line.strip()
        if line == 'EOF' or line == 'exit' or line == 'quit':
            raise self.SessionCmdExit()
        line = line.split('\\')
        line = '\\\\'.join(line)
        line = line.split('"')
        line = '\\"'.join(line)
        line = line.split('$')
        line = '\\$'.join(line)
        line = 'eval "' + line + '" < /dev/null'

        return line

    def executeCommand(self, command):
        commandoutput = []

        if self.echoCommand:
            escapedCommand = command.replace('"', '\\"')
            command = 'echo "%s"; %s' % (escapedCommand, command)

        # Execute the command in all of the ssh sessions
        for s in self.pxssh_list:
            s.sendline(command)

        # Wait for each command and retrieve the output
        for s in self.pxssh_list:
            # Wait for each command to finish
            # !! TODO verify that this is a tight wait loop and find another way to do this
            while not s.prompt(120) and s.isalive() and not s.eof(): pass

        for s in self.pxssh_list:
            # Split the output into an array of lines so that we can add text to the beginning of
            #    each line
            output = to_str(s.before).split(CRNL)
            output = output[1:-1]

            commandoutput.append(output)

        return commandoutput.__iter__()

    # Interactive command line handler
    #    Override of base class, handles commands that aren't recognized as part of a predefined set
    #    The "command" argument is a command line to be executed on all available command sessions
    #    The output of the command execution is printed to the standard output, prepended with
    #        the hostname of each machine from which the output came
    def default(self, command):

        line = self.escapeLine(command)

        if self.verbose: print(command)

        # Execute the command on our ssh sessions
        commandoutput = self.executeCommand(command)
        self.writeCommandOutput(commandoutput)

    def writeCommandOutput(self, commandoutput):
        '''Takes a list of output lists as an iterator and writes them to standard output,
        formatted with the hostname from which each output array was obtained'''
        for s in self.pxssh_list:
            output = next(commandoutput)
            # Write the output
            if len(output) == 0:
                print(self.peerStringFormat() % s.x_peer)
            else:
                for line in output:
                    print((self.peerStringFormat() % s.x_peer), line)

    def closePxsshList(self, list):
        lock = threading.Lock()
        return_codes = [0]

        def closePxsshOne(p, return_codes):
            p.logout()
            with lock:
                return_codes.append(p.exitstatus)

        th = []
        for p in list:
            t = threading.Thread(target=closePxsshOne, args=(p, return_codes))
            t.start()
            th.append(t)
        for t in th:
            t.join()
        return max(return_codes)
